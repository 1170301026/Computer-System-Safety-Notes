# 访问控制矩阵的实现

### 一. 访问控制矩阵

* 操作系统所提供访问控制

  –密码或Kerbros等验证机制

  –当用户访问文件、端口等系统资源时进行权限检查

* 模型化为访问权限矩阵,行表示用户,列表示文件

* **进程**访问**资源**时，参考监控器(Reference monitor) 要检查所有的访问操作

  –完全的监控: 控制所有资源的访问

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200105180113553.png" alt="image-20200105180113553" style="zoom:67%;" />

###### a.模型：

* 访问控制矩阵：准确的描述了保护状态的模型。描述一个主体（进程）相对于系统中其他实体的权限

  -矩阵中元素构成了当前系统的状态

  -系统状态是不断变化的。读数据、加载程序、修改数据等都导致状态转换

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200105180609201.png" alt="image-20200105180609201" style="zoom:67%;" />

* 基本要素：

  * 主体 Subjects

  * 客体 Objects

  * 权限 Rights

  -表格中的内容指明了主体(行)对客体(列)访问权限

> eg.访问控制矩阵举例：

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200105183345024.png" alt="image-20200105183345024" style="zoom: 80%;" />

###### b.用户和访问原则

![image-20200105183836746](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200105183836746.png)

* 一对多的关系,一个用户可以有多个访问原则

  每个访问原则仅属于一个用户

* 访问原则：能够保证用户的行为具有各自的责任

* **主体**

  是代表一个具有访问原则的运行着的程序或应用

  在某时刻可能无访问原则，访问原则也可代表一个或多个主体运行

* **客体**

  主体可操作的都可称为客体（访问客体时需要权限）

  通常客体是被操作对象：

  * 文件
  * 目录
  * 内存段

  主体也可作为客体使用 (eg.kill suspend resume) 

### 二. 访问控制矩阵的实现形式

#### 1.访问控制列表ACL

* 抽象描述

  –客体集合O是被保护实体的集合（所有与系统保护状态有关的实体）

  –主体集S是所有活动客体的集合，进程和用户

  –权限集合R

  –访问控制矩阵中，客体集合O和主体集S间的关系用带有权限的矩阵A表示，a表示权限，a[s,o]表示主体s对客体o的权限

  –所有**保护状态集合**可以用三元组(S,O,A)表示

* 优点：

  –访问控制策略集中设置

  –适合于面向数据的保护环境

  –容易执行

> ACL示例：
> –Sam是系统管理员（具有所有权限）
> –Alice, 普通用户（需要系统程序和应用程序的运行权限）
> –Bob, 审计人员 （可以读所有文件）
>
> ![image-20200105193217272](C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200105193217272.png)

* UNIX中的ACL

  访问策略:

  –建立访问三元组

  * user
  * program
  * file

  Unix提供间接方法:

  –**suid** **and** **sgid**

  –**利用操作系统的方法解决应用程序的权限**, **会引发很多问题**

* 缺点：

  –用户多、用户经常变化

  ​	eg.数据库

  –当用户想授权给他人在某时间段使用

  –运行时的安全检查不够充分

  –查询用户对哪些文件有权限：困难

#### 2.能力表

* 访问矩阵的行表示形式，每行表示主体的能力

* 能力表实现访问控制矩阵的行控制

  每一个主体与一个序对集合关联，每一序对包含一个客体和一个权限集合。主体对客体的权限在序对中表示

  –O客体集合，R权限集合，能力表c是序对c=|(o,r):o属于O,r属于R|的集合。cap为主体s映射为能力表c的函数，cap(s)=|(oi,ri):1≤i≤n|

  > 如cap(process1)={(file1,{read,write,execute,own}),(process1,{read,own})}

* 实现：

<img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200105194818582.png" alt="image-20200105194818582" style="zoom: 80%;" />

#### 3.关系

访问控制三元组(常用于关系数据库DBMS)

| SUBJECT | Access | object |
| ------- | ------ | ------ |
| U       | r      | F      |
| U       | w      | F      |
| U       | own    | F      |
| U       | r      | G      |
| V       | r      | G      |
| V       | w      | G      |
| V       | own    | G      |

#### 4.ACL vs. Capabilities

###### a.混淆责任问题

* 编译器运行时，执行两个用户的权限

  –用户

  –编译用户 (安装编译器、控制管理运行清单等维护信息)

* 系统没法区分：应为哪个用户服务

* Capability能够解决混淆责任问题

  •编译程序compiler的权能：访问SYSX/STAT和SYSX/BILL, 权限存放在自己的能力槽(slots 1 & 2)

  •应用者运行compiler,有写文件权限, 其权限存放在能力槽(slot 3). 应用者没有写SYSX/BILL文件的权限，因为授权时没有赋予相应的权限

  •当写入billing信息时, 编译程序使用slot 2中的权限. 当写输出信息时, 使用slot 3中的权限

###### b.访问控制模式不是动态的

* 访问矩阵不能包含确切的规则：不能指定矩阵值在何时被更新
* 描述的安全机制不完全，无法描述访问关系随时间的变化
* 仅从静态角度比较ACL和capability模型是不够的，不能说明其逻辑等价性

###### c.命名空间

* ACL ：需要客体的命名空间

  在能力表系统： 能力表同时指定资源和权限

  对主体也需要命名空间

  –主体不能太多，不能经常变化

  –多数ACL系统把用户作为主体, 不支持细粒度的主体区分

  ACL系统中, 授权给**资源**相应的访问权限

  –产生自主访问控制, 通常由文件拥有者指定权限

* Capability：能力表同时指定资源和权限

  主体-聚集的权限管理

  –在能力表系统中, 授权给**主体**相应的权限

###### d.权利边界

* 权利边界：意味着用户的权限是自动执行，不需要选择某个权限去执行

  –ACL引发混淆责任问题

  –在能力表系统中，权限清晰，无额外的权限

###### e.主体鉴别

* ACL需要鉴别主体
* 能力表不需要鉴别主体, 但需要控制权限的传播

###### f.权限审查及撤销权限

* 权限审查

  ACL：提供单客体的权限审查

  Capabilities：提供单主体的权限审查

* 撤销权限

  ACL撤销权限：基于单客体的撤销功能

  Capabilities撤销权限： 基于单主体的撤销

###### g.最小特权原则

* 对主体来说，能力表提供了细粒度的最小特权控制, 对某特定任务可提供动态地、短时间访问

### 三.自主访问控制与强制访问控制

* 自主访问(DAC)控制是依据主体的判断力授予访问权限 

  –通常由客体的拥有者授权

* 强制访问控制(MAC)按照系统级策略限制主体对客体的访问

  –对用户所创建的资源，也拒绝用户的完全控制. 系统的安全策略(管理员设置)完全取决于其权限