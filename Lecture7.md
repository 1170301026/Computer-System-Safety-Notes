### 一.机密性模型

* 目标: 防止非授权的泄漏信息

  * 处理信息流

  信息的动态变化过程中保护信息不被泄露

* 多级安全模型
* 防止信息从高安全级流向低安全级
* Bell-LaPadula 模型是很多模型的基础

### 二.Bell-LaPadula

#### 1.BLP模型，步骤1

##### 1)信息的安全级

* 信息安全级别：线序
  * 绝密Top Secret: highest
  * 机密Secret
  * 秘密Confidential
  * 公开Unclassified: lowest

* 主体的安全许可*L(s)*
* 客体的安全级*L(o)*

> <img src="C:\Users\13797\AppData\Roaming\Typora\typora-user-images\image-20200105234419608.png" alt="image-20200105234419608" style="zoom: 80%;" />

* *Tamara 可读所有文件*
* *Claire 可读Logs和Lists*
* *Ulaley 可读Lists*

##### 2)读信息

* 信息向上(安全级别高)流动, 非向下(安全级别低)流动

  * “上读” 不允许, “下读” 允许
  * “禁止上读” 规则

* 简单的安全条件(Step 1)

  * 主体 *s* 可以读客体 *o*：iff *L*(*o*) ≤ *L*(*s*) 且s对o有读权限（当且仅当 iff）

  * 包含强制访问控制(安全级关系)和自主访问控制 (读权限)

    

##### 3)写信息

* 信息向上流动, 不向下流动

  * 允许“向上写”, 不允许“向下写”
  * “禁止下写” 规则

* *-属性 (Step 1)

  * 主体可以写客体 *o* ，iff *L*(*s*) ≤ *L*(*o*) 且主体*s* 对 *o*有写权限

  * 包含强制访问控制 (安全级) 和自主访问控制 (写权限)

##### 4)基本安全定理(步骤1)

* 如果一个系统初始于一个安全状态：    

     系统的每次转换,**都满足步骤1的基本安全条件**, 和*-属性;

     那么系统的每个状态都是安全的

#### 2.BLP模型，步骤2

* 安全级的概念扩展，对客体分类

* 安全级(*级别*, *分类*)


##### 1)格序

* A是安全级,C是安全分类

* (*A*, *C*) *dom* (A’, C’) **iff *A*’≤ *A* 和 C’ 属于 *C***

     *dom*: 控制

* 安全级集合 *L = A* ** C*, *dom* 形成格序

  * 最小上界lub*(*L*) = (*max*(*A*)*, *C*)

  * 最大下界glb(*L*) = (*min*(*A*), 空集)

> ( Top Secret, { NUC, EUR, ASI } )
> ( Confidential, { EUR, ASI } )
> ( Secret, { NUC, ASI } )

* 步骤2中：安全级L是**偏序**关系

  **并非所有安全级之间可以进行比较**

* 步骤1中“dom” 含义是 “greater than”

    “greater than” 是全序

##### 2)读信息

* 信息向上流动, 不能向下流动

  “读高于本级信息”不允许, “读低于本级信息”允许

* 简单安全条件 (Step 2)

  主体 *s* 可以读客体 *o**：*iff *L*(*s*) *dom* *L*(*o*) 且 *s* 对 *o* 有读权限

  * 包含强制访问控制和自主访问控制

##### 3)写信息

* 信息向上流动,不向下流动

  “上写” 允许, “下写”不允许

* *-Property (Step 2)

  主体s能写客体o，iff *L*(*o*) *dom* *L*(*s*) 且*s*对*o*有写权限

  * 包含强制访问控制和自主访问控制

##### 4)基本安全定理

* 如果一个系统初始于一个安全状态;

  系统的每次转换,都满足步骤2的基本安全条件, 和*-属性;那么系统的每个状态都是安全的

##### 5)解决上级向下写问题

* 对主体，定义最大级别, 当前级别

  *maxlevel*(*s*) *dom* *curlevel*(*s*)

> eg.Major 是客体 (Colonel 要写入信息)
> Colonel 的 *maxlevel* (Secret, { NUC, EUR })
> Colonel 的 *curlevel* to (Secret, { EUR })
> *L*(Major) *dom* *curlevel*(Colonel)
> Colonel 可以向 Major 写信息

### 三.DG/UX System

* 提供强制访问控制
  * MAC 标签指明安全级
  * 有缺省标签, 也可定义标签
* 初始
  * 主体的标签：指定为用户, 保存在授权与鉴别数据库中
  * 客体在创建时建立标签显式标签，是属性的一部分隐式标签，从父目录获得

#### 1.目录的标签问题

> 进程 *p* (MAC_A标签) 想创建文件*/**tmp**/x*
>    */**tmp**/x* 已经存在，MAC标签为MAC_B并且 MAC_B dom MAC_A

​			---->无法创建！

* 补救措施：在某目录中，仅相同MAC标签的程序可在该目录中创建文件

#### 2.多级目录

* 目录下有子目录, 每个子目录一个标签
* 子目录对用户透明，用户不可见子目录p 创建 /**tmp**/x，其实创建的是/**tmp**/d/x ，d is是MAC_A标签对应的目录
* 所有 p指向*/tmp*的参考文件均改为指向*/**tmp**/d*

* 进程 p运行：cd */**tmp**/a*, cd ..
* 系统调用stat(“.”, &buf) 返回真正目录的inode号
* 在DG/UX系统中，系统调用 dg_stat(“.”, &buf) 返回*/tmp*的inode

#### 3.加载没有标签的文件系统

* 要求: 文件系统客体（文件）必须有MAC标签

    1）文件系统的根有显式的MAC标签

    2）如果mount到一个无标签的文件系统, 其标签为mount点的标签，隐式继承其父亲的MAC标签

    3）创建客体的硬链接，客体必须有显式标签；如果没有显式标签，把隐式标签转为显示标签

    4）如果目录的标签要改变，子目录的隐式标签转为显示标签

    5）系统解析符号链接时，客体标签就是符号链接目标的标签

#### 4.客体标签

* 问题: 客体有2个名字

  */x/y/z*, */a/b/c* 指向同一个客体

  * *y* 有显式标签 IMPL_HIl
  * *b* 有隐式标签 IMPL_Bl

* 情况1: 硬连接

  创建硬连接需要有显式标签

  * 如果标签为隐式, 需将标签改为显式
  * 含义：移动文件时需将标签改为显式

* 情况2: 当mount到文件系统时，硬连接存在

  该路径上的所有客体标签均为隐式: 路径下的隐式标签都相同

  改变目录标签时，在改变前需将儿子的标签改为显式

* 符号连接是文件, 规则同文件的规则
  * 当解析符号连接时, 符号连接的标签为其指向文件的标签
  * 系统需要访问符号连接本身的标签

#### 5.MAC标签
